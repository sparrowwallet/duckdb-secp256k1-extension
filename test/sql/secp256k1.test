# name: test/sql/secp256k1.test
# description: test secp256k1 extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT secp256k1_ec_pubkey_combine([from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')]);
----
Catalog Error: Scalar Function with name secp256k1_ec_pubkey_combine does not exist!

# Require statement will ensure this test is run with this extension loaded
require secp256k1

# Test combining two valid compressed public keys
# Using secp256k1 generator point (0279be...) and another valid compressed pubkey
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')
]) IS NOT NULL;
----
true

# Test combining three public keys
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5'),
    from_hex('03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb')
]) IS NOT NULL;
----
true

# Test with NULL input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine(NULL);
----
NULL

# Test with invalid length input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), 
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')
]);
----
NULL

# Test with invalid public key data (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0000000000000000000000000000000000000000000000000000000000000000000'), 
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')
]);
----
NULL

# Test create_outpoint function with 32-byte blob and integer
query I
SELECT octet_length(create_outpoint(
    from_hex('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'),
    1
));
----
36

# Test create_outpoint with zero integer (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    0
) = from_hex('000000000000000000000000000000000000000000000000000000000000000000000000');
----
true

# Test create_outpoint with integer 1 (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    1
) = from_hex('000000000000000000000000000000000000000000000000000000000000000001000000');
----
true

# Test create_outpoint with integer 256 (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    256
) = from_hex('000000000000000000000000000000000000000000000000000000000000000000010000');
----
true

# Test create_outpoint with NULL blob (should return NULL)
query I
SELECT create_outpoint(NULL, 1);
----
NULL

# Test create_outpoint with NULL integer (should return NULL)
query I
SELECT create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), NULL);
----
NULL

# Test create_outpoint with wrong blob length (should return NULL)
query I
SELECT create_outpoint(from_hex('00000000000000000000000000000000000000000000000000000000000000'), 1);
----
NULL

# Test min_outpoint function with two outpoints
query I
SELECT min_outpoint([
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 2),
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1)
]) = create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1);
----
true

# Test min_outpoint with three outpoints (different hash prefixes)
query I
SELECT min_outpoint([
    create_outpoint(from_hex('1000000000000000000000000000000000000000000000000000000000000000'), 0),
    create_outpoint(from_hex('0100000000000000000000000000000000000000000000000000000000000000'), 0),
    create_outpoint(from_hex('2000000000000000000000000000000000000000000000000000000000000000'), 0)
]) = create_outpoint(from_hex('0100000000000000000000000000000000000000000000000000000000000000'), 0);
----
true

# Test min_outpoint with all NULL inputs (should return NULL)
query I
SELECT min_outpoint(NULL);
----
NULL

# Test min_outpoint with wrong length input (ignores invalid, returns valid)
query I
SELECT min_outpoint([
    from_hex('00000000000000000000000000000000000000000000000000000000000000000'),  -- 33 bytes (wrong)
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1)
]) = create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1);
----
true

# Test secp256k1_tagged_sha256 function basic functionality
query I
SELECT octet_length(secp256k1_tagged_sha256('test_tag', 'test_message'));
----
32

# Test secp256k1_tagged_sha256 produces different hashes for different tags
query I
SELECT secp256k1_tagged_sha256('tag1', 'message') != secp256k1_tagged_sha256('tag2', 'message');
----
true

# Test secp256k1_tagged_sha256 produces different hashes for different messages
query I
SELECT secp256k1_tagged_sha256('tag', 'message1') != secp256k1_tagged_sha256('tag', 'message2');
----
true

# Test secp256k1_tagged_sha256 is deterministic (same inputs produce same output)
query I
SELECT secp256k1_tagged_sha256('BIP0340/challenge', 'Hello') = secp256k1_tagged_sha256('BIP0340/challenge', 'Hello');
----
true

# Test secp256k1_tagged_sha256 with binary data
query I
SELECT octet_length(secp256k1_tagged_sha256('binary_test', from_hex('deadbeef')));
----
32

# Test secp256k1_tagged_sha256 with NULL tag (should return NULL)
query I
SELECT secp256k1_tagged_sha256(NULL, 'message');
----
NULL

# Test secp256k1_tagged_sha256 with NULL message (should return NULL)
query I
SELECT secp256k1_tagged_sha256('tag', NULL);
----
NULL

# Test secp256k1_tagged_sha256 with both NULL inputs (should return NULL)
query I
SELECT secp256k1_tagged_sha256(NULL, NULL);
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul basic functionality
query I
SELECT octet_length(secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000002')
));
----
33

# Test secp256k1_ec_pubkey_tweak_mul identity tweak (multiply by 1)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000001')
) = from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');
----
true

# Test secp256k1_ec_pubkey_tweak_mul different tweaks produce different results
query I
SELECT secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000002')
) != secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000003')
);
----
true

# Test secp256k1_ec_pubkey_tweak_mul with NULL pubkey (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(NULL, from_hex('0000000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with NULL tweak (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), NULL);
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with wrong pubkey length (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), from_hex('0000000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with wrong tweak length (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('00000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with zero tweak (should return NULL - invalid)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('0000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test int_to_big_endian basic functionality
query I
SELECT octet_length(int_to_big_endian(123));
----
4

# Test int_to_big_endian with zero
query I
SELECT int_to_big_endian(0) = from_hex('00000000');
----
true

# Test int_to_big_endian with one (big-endian format)
query I
SELECT int_to_big_endian(1) = from_hex('00000001');
----
true

# Test int_to_big_endian with 256 (big-endian format)
query I
SELECT int_to_big_endian(256) = from_hex('00000100');
----
true

# Test int_to_big_endian with 65536 (big-endian format)
query I
SELECT int_to_big_endian(65536) = from_hex('00010000');
----
true

# Test int_to_big_endian with negative number (two's complement)
query I
SELECT int_to_big_endian(-1) = from_hex('FFFFFFFF');
----
true

# Test int_to_big_endian with max 32-bit signed integer
query I
SELECT int_to_big_endian(2147483647) = from_hex('7FFFFFFF');
----
true

# Test int_to_big_endian with min 32-bit signed integer  
query I
SELECT int_to_big_endian(-2147483648) = from_hex('80000000');
----
true

# Test int_to_big_endian with NULL input (should return NULL)
query I
SELECT int_to_big_endian(NULL);
----
NULL

# Test hash_prefix_to_int basic functionality (takes first 8 bytes as MSB)
query I
SELECT hash_prefix_to_int(from_hex('0000000000000001000000000000000000000000000000000000000000000000'));
----
1

# Test hash_prefix_to_int with zero input
query I
SELECT hash_prefix_to_int(from_hex('0000000000000000000000000000000000000000000000000000000000000000'));
----
0

# Test hash_prefix_to_int with max 8-byte value (big-endian)
query I
SELECT hash_prefix_to_int(from_hex('FFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000'));
----
18446744073709551615

# Test hash_prefix_to_int with small value in MSB position
query I
SELECT hash_prefix_to_int(from_hex('0100000000000000000000000000000000000000000000000000000000000000'));
----
72057594037927936

# Test hash_prefix_to_int with NULL input (should return NULL)
query I
SELECT hash_prefix_to_int(NULL);
----
NULL

# Test hash_prefix_to_int with wrong length input (should return NULL)
query I
SELECT hash_prefix_to_int(from_hex('00000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test secp256k1_ec_pubkey_create basic functionality
query I
SELECT octet_length(secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')));
----
33

# Test secp256k1_ec_pubkey_create with known test vector (private key = 1)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) = from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');
----
true

# Test secp256k1_ec_pubkey_create with another test vector (private key = 2)
query I
SELECT octet_length(secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')));
----
33

# Test secp256k1_ec_pubkey_create with different private keys produces different public keys
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) != secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002'));
----
true

# Test secp256k1_ec_pubkey_create with NULL input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(NULL);
----
NULL

# Test secp256k1_ec_pubkey_create with wrong length input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test secp256k1_ec_pubkey_create with zero private key (should return NULL - invalid)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test secp256k1_ec_pubkey_create with max valid private key (n-1 where n is secp256k1 order)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140')) IS NOT NULL;
----
true

# Test secp256k1_ec_pubkey_create with invalid private key (secp256k1 order, should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'));
----
NULL

# BIP 352 Silent Payments scanning test (k=0) using first test vector
# This implements the BIP 352 scanning algorithm for the first receiving test case
query I
WITH 
  -- Test vector data from BIP 352 test vectors (first receiving element)
  spend_priv AS (SELECT from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3') as key),
  scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1f2c') as key),
  
  -- Input public keys from the test vector transaction (extracted from inputs)
  input_pubkeys AS (
    SELECT [
      secp256k1_ec_pubkey_create(from_hex('eadc78165ff1f8ea94ad7cfdc54990738a4c53f6e0507b42154201b8e5dff3b1')),  -- First input pubkey
      secp256k1_ec_pubkey_create(from_hex('93f5ed907ad5b2bdbbdcb5d9116ebc0a4e1f92f910d5260237fa45a9408aad16'))   -- Second input pubkey  
    ] as pubkeys
  ),
  
  -- Create outpoints from the test vector inputs
  outpoints AS (
    SELECT [
      create_outpoint(from_hex('f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16'), 0),
      create_outpoint(from_hex('a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d'), 0)
    ] as ops
  ),
  
  -- BIP 352 scanning algorithm implementation
  scan_calculation AS (
    SELECT 
      -- Step 1: Find smallest outpoint (lexicographically)
      min_outpoint(ops) as smallest_outpoint,
      
      -- Step 2: Sum input public keys
      secp256k1_ec_pubkey_combine(pubkeys) as combined_pubkey,
      
      -- Step 3: Derive spending public key from private key
      secp256k1_ec_pubkey_create((SELECT key FROM spend_priv)) as spend_pubkey,
      
      -- Reference values for verification  
      (SELECT key FROM scan_priv) as scan_private_key
    FROM input_pubkeys, outpoints
  ),
  
  -- Calculate the BIP 352 shared secret
  secret_calculation AS (
    SELECT 
      smallest_outpoint,
      combined_pubkey,
      spend_pubkey,
      scan_private_key,
      
      -- Step 4: For k=0, compute t_0 = tagged_sha256("BIP0352/SharedSecret", input_hash || int_to_big_endian(0))
      secp256k1_ec_pubkey_tweak_mul(
      	secp256k1_ec_pubkey_tweak_mul(combined_pubkey, 
          secp256k1_tagged_sha256('BIP0352/Inputs', smallest_outpoint || combined_pubkey)), scan_private_key
      ) as ecdh_shared_secret
    FROM scan_calculation
  ),
  
  -- Calculate the BIP 352 t_0
  t_0_calculation AS (
    SELECT 
      ecdh_shared_secret,
        
        -- Step 5: For k=0, compute t_0 = tagged_sha256("BIP0352/SharedSecret", input_hash || int_to_big_endian(0))
        secp256k1_tagged_sha256('BIP0352/SharedSecret',
          ecdh_shared_secret || int_to_big_endian(0)
        ) as t_0
        
      FROM secret_calculation
    )
SELECT secp256k1_ec_pubkey_combine([spend_pubkey, secp256k1_ec_pubkey_create(t_0)]) = from_hex('033e9fce73d4e77a4809908e3c3a2e54ee147b9312dc5044a193d1fc85de46e3c1')
FROM t_0_calculation, scan_calculation;
----
true

# BIP 352 Silent Payments tweak index test (k=0) using first test vector
# This calculates the tweak
query I
WITH 
  -- Input public keys from the test vector transaction (extracted from inputs)
  input_pubkeys AS (
    SELECT [
      secp256k1_ec_pubkey_create(from_hex('eadc78165ff1f8ea94ad7cfdc54990738a4c53f6e0507b42154201b8e5dff3b1')),  -- First input pubkey
      secp256k1_ec_pubkey_create(from_hex('93f5ed907ad5b2bdbbdcb5d9116ebc0a4e1f92f910d5260237fa45a9408aad16'))   -- Second input pubkey  
    ] as pubkeys
  ),
  
  -- Create outpoints from the test vector inputs
  outpoints AS (
    SELECT [
      create_outpoint(from_hex('f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16'), 0),
      create_outpoint(from_hex('a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d'), 0)
    ] as ops
  ),
  
  combined_pubkey AS (
  	SELECT
  	  secp256k1_ec_pubkey_combine(pubkeys) as combined_pubkey
  	FROM input_pubkeys
  )
  
SELECT secp256k1_ec_pubkey_tweak_mul(combined_pubkey, 
                 secp256k1_tagged_sha256('BIP0352/Inputs', min_outpoint(ops) || combined_pubkey)) = from_hex('024ac253c216532e961988e2a8ce266a447c894c781e52ef6cee902361db960004')
  FROM combined_pubkey, outpoints;
----
true
