# name: test/sql/secp256k1.test
# description: test secp256k1 extension
# group: [sql]

# Before we load the extension, this will fail
statement error
SELECT secp256k1_ec_pubkey_combine([from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')]);
----
Catalog Error: Scalar Function with name secp256k1_ec_pubkey_combine does not exist!

# Require statement will ensure this test is run with this extension loaded
require secp256k1

# Test combining two valid compressed public keys
# Using secp256k1 generator point (0279be...) and another valid compressed pubkey
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')
]) IS NOT NULL;
----
true

# Test combining three public keys
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5'),
    from_hex('03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb')
]) IS NOT NULL;
----
true

# Test with NULL input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine(NULL);
----
NULL

# Test with invalid length input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), 
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')
]);
----
NULL

# Test with invalid public key data (should return NULL)
query I
SELECT secp256k1_ec_pubkey_combine([
    from_hex('0000000000000000000000000000000000000000000000000000000000000000000'), 
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')
]);
----
NULL

# Test create_outpoint function with 32-byte blob and integer
query I
SELECT octet_length(create_outpoint(
    from_hex('0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef'),
    1
));
----
36

# Test create_outpoint with zero integer (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    0
) = from_hex('000000000000000000000000000000000000000000000000000000000000000000000000');
----
true

# Test create_outpoint with integer 1 (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    1
) = from_hex('000000000000000000000000000000000000000000000000000000000000000001000000');
----
true

# Test create_outpoint with integer 256 (little-endian encoding)
query I
SELECT create_outpoint(
    from_hex('0000000000000000000000000000000000000000000000000000000000000000'),
    256
) = from_hex('000000000000000000000000000000000000000000000000000000000000000000010000');
----
true

# Test create_outpoint with NULL blob (should return NULL)
query I
SELECT create_outpoint(NULL, 1);
----
NULL

# Test create_outpoint with NULL integer (should return NULL)
query I
SELECT create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), NULL);
----
NULL

# Test create_outpoint with wrong blob length (should return NULL)
query I
SELECT create_outpoint(from_hex('00000000000000000000000000000000000000000000000000000000000000'), 1);
----
NULL

# Test min_outpoint function with two outpoints
query I
SELECT min_outpoint([
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 2),
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1)
]) = create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1);
----
true

# Test min_outpoint with three outpoints (different hash prefixes)
query I
SELECT min_outpoint([
    create_outpoint(from_hex('1000000000000000000000000000000000000000000000000000000000000000'), 0),
    create_outpoint(from_hex('0100000000000000000000000000000000000000000000000000000000000000'), 0),
    create_outpoint(from_hex('2000000000000000000000000000000000000000000000000000000000000000'), 0)
]) = create_outpoint(from_hex('0100000000000000000000000000000000000000000000000000000000000000'), 0);
----
true

# Test min_outpoint with all NULL inputs (should return NULL)
query I
SELECT min_outpoint(NULL);
----
NULL

# Test min_outpoint with wrong length input (ignores invalid, returns valid)
query I
SELECT min_outpoint([
    from_hex('00000000000000000000000000000000000000000000000000000000000000000'),  -- 33 bytes (wrong)
    create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1)
]) = create_outpoint(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 1);
----
true

# Test secp256k1_tagged_sha256 function basic functionality
query I
SELECT octet_length(secp256k1_tagged_sha256('test_tag', 'test_message'));
----
32

# Test secp256k1_tagged_sha256 produces different hashes for different tags
query I
SELECT secp256k1_tagged_sha256('tag1', 'message') != secp256k1_tagged_sha256('tag2', 'message');
----
true

# Test secp256k1_tagged_sha256 produces different hashes for different messages
query I
SELECT secp256k1_tagged_sha256('tag', 'message1') != secp256k1_tagged_sha256('tag', 'message2');
----
true

# Test secp256k1_tagged_sha256 is deterministic (same inputs produce same output)
query I
SELECT secp256k1_tagged_sha256('BIP0340/challenge', 'Hello') = secp256k1_tagged_sha256('BIP0340/challenge', 'Hello');
----
true

# Test secp256k1_tagged_sha256 with binary data
query I
SELECT octet_length(secp256k1_tagged_sha256('binary_test', from_hex('deadbeef')));
----
32

# Test secp256k1_tagged_sha256 with NULL tag (should return NULL)
query I
SELECT secp256k1_tagged_sha256(NULL, 'message');
----
NULL

# Test secp256k1_tagged_sha256 with NULL message (should return NULL)
query I
SELECT secp256k1_tagged_sha256('tag', NULL);
----
NULL

# Test secp256k1_tagged_sha256 with both NULL inputs (should return NULL)
query I
SELECT secp256k1_tagged_sha256(NULL, NULL);
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul basic functionality
query I
SELECT octet_length(secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000002')
));
----
33

# Test secp256k1_ec_pubkey_tweak_mul identity tweak (multiply by 1)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000001')
) = from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');
----
true

# Test secp256k1_ec_pubkey_tweak_mul different tweaks produce different results
query I
SELECT secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000002')
) != secp256k1_ec_pubkey_tweak_mul(
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    from_hex('0000000000000000000000000000000000000000000000000000000000000003')
);
----
true

# Test secp256k1_ec_pubkey_tweak_mul with NULL pubkey (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(NULL, from_hex('0000000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with NULL tweak (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), NULL);
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with wrong pubkey length (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), from_hex('0000000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with wrong tweak length (should return NULL)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('00000000000000000000000000000000000000000000000000000000000001'));
----
NULL

# Test secp256k1_ec_pubkey_tweak_mul with zero tweak (should return NULL - invalid)
query I
SELECT secp256k1_ec_pubkey_tweak_mul(from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), from_hex('0000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test int_to_big_endian basic functionality
query I
SELECT octet_length(int_to_big_endian(123));
----
4

# Test int_to_big_endian with zero
query I
SELECT int_to_big_endian(0) = from_hex('00000000');
----
true

# Test int_to_big_endian with one (big-endian format)
query I
SELECT int_to_big_endian(1) = from_hex('00000001');
----
true

# Test int_to_big_endian with 256 (big-endian format)
query I
SELECT int_to_big_endian(256) = from_hex('00000100');
----
true

# Test int_to_big_endian with 65536 (big-endian format)
query I
SELECT int_to_big_endian(65536) = from_hex('00010000');
----
true

# Test int_to_big_endian with negative number (two's complement)
query I
SELECT int_to_big_endian(-1) = from_hex('FFFFFFFF');
----
true

# Test int_to_big_endian with max 32-bit signed integer
query I
SELECT int_to_big_endian(2147483647) = from_hex('7FFFFFFF');
----
true

# Test int_to_big_endian with min 32-bit signed integer  
query I
SELECT int_to_big_endian(-2147483648) = from_hex('80000000');
----
true

# Test int_to_big_endian with NULL input (should return NULL)
query I
SELECT int_to_big_endian(NULL);
----
NULL

# Test hash_prefix_to_int basic functionality (takes 8 bytes starting at offset 0)
query I
SELECT hash_prefix_to_int(from_hex('0000000000000001000000000000000000000000000000000000000000000000'), 0);
----
1

# Test hash_prefix_to_int with zero input
query I
SELECT hash_prefix_to_int(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 0);
----
0

# Test hash_prefix_to_int with max 8-byte value (big-endian)
query I
SELECT hash_prefix_to_int(from_hex('FFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000'), 0);
----
-1

# Test hash_prefix_to_int with small value in MSB position
query I
SELECT hash_prefix_to_int(from_hex('0100000000000000000000000000000000000000000000000000000000000000'), 0);
----
72057594037927936

# Test hash_prefix_to_int with offset (read from byte 8)
query I
SELECT hash_prefix_to_int(from_hex('00000000000000000000000000000001000000000000000000000000000000'), 8);
----
1

# Test hash_prefix_to_int with offset at end (read last 8 bytes)
query I
SELECT hash_prefix_to_int(from_hex('000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF'), 24);
----
-1

# Test hash_prefix_to_int with NULL blob input (should return NULL)
query I
SELECT hash_prefix_to_int(NULL, 0);
----
NULL

# Test hash_prefix_to_int with NULL offset input (should return NULL)
query I
SELECT hash_prefix_to_int(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), NULL);
----
NULL

# Test hash_prefix_to_int with insufficient length (should return NULL)
query I
SELECT hash_prefix_to_int(from_hex('00000000000000'), 0);
----
NULL

# Test hash_prefix_to_int with offset beyond blob length (should return NULL)
query I
SELECT hash_prefix_to_int(from_hex('0000000000000000000000000000000000000000000000000000000000000000'), 25);
----
NULL

# Test secp256k1_ec_pubkey_create basic functionality
query I
SELECT octet_length(secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')));
----
33

# Test secp256k1_ec_pubkey_create with known test vector (private key = 1)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) = from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');
----
true

# Test secp256k1_ec_pubkey_create with another test vector (private key = 2)
query I
SELECT octet_length(secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')));
----
33

# Test secp256k1_ec_pubkey_create with different private keys produces different public keys
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) != secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002'));
----
true

# Test secp256k1_ec_pubkey_create with NULL input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(NULL);
----
NULL

# Test secp256k1_ec_pubkey_create with wrong length input (should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test secp256k1_ec_pubkey_create with zero private key (should return NULL - invalid)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000000'));
----
NULL

# Test secp256k1_ec_pubkey_create with max valid private key (n-1 where n is secp256k1 order)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140')) IS NOT NULL;
----
true

# Test secp256k1_ec_pubkey_create with invalid private key (secp256k1 order, should return NULL)
query I
SELECT secp256k1_ec_pubkey_create(from_hex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'));
----
NULL

# BIP 352 Silent Payments scanning test (k=0) using first test vector
# This implements the BIP 352 scanning algorithm for the first receiving test case
query I
WITH 
  -- Test vector data from BIP 352 test vectors (first receiving element)
  spend_priv AS (SELECT from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3') as key),
  scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1f2c') as key),
  
  -- Input public keys from the test vector transaction (extracted from inputs)
  input_pubkeys AS (
    SELECT [
      secp256k1_ec_pubkey_create(from_hex('eadc78165ff1f8ea94ad7cfdc54990738a4c53f6e0507b42154201b8e5dff3b1')),  -- First input pubkey
      secp256k1_ec_pubkey_create(from_hex('93f5ed907ad5b2bdbbdcb5d9116ebc0a4e1f92f910d5260237fa45a9408aad16'))   -- Second input pubkey  
    ] as pubkeys
  ),
  
  -- Create outpoints from the test vector inputs
  outpoints AS (
    SELECT [
      create_outpoint(from_hex('f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16'), 0),
      create_outpoint(from_hex('a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d'), 0)
    ] as ops
  ),
  
  -- BIP 352 scanning algorithm implementation
  scan_calculation AS (
    SELECT 
      -- Step 1: Find smallest outpoint (lexicographically)
      min_outpoint(ops) as smallest_outpoint,
      
      -- Step 2: Sum input public keys
      secp256k1_ec_pubkey_combine(pubkeys) as combined_pubkey,
      
      -- Step 3: Derive spending public key from private key
      secp256k1_ec_pubkey_create((SELECT key FROM spend_priv)) as spend_pubkey,
      
      -- Reference values for verification  
      (SELECT key FROM scan_priv) as scan_private_key
    FROM input_pubkeys, outpoints
  ),
  
  -- Calculate the BIP 352 shared secret
  secret_calculation AS (
    SELECT 
      smallest_outpoint,
      combined_pubkey,
      spend_pubkey,
      scan_private_key,
      
      -- Step 4: For k=0, compute t_0 = tagged_sha256("BIP0352/SharedSecret", input_hash || int_to_big_endian(0))
      secp256k1_ec_pubkey_tweak_mul(
      	secp256k1_ec_pubkey_tweak_mul(combined_pubkey, 
          secp256k1_tagged_sha256('BIP0352/Inputs', smallest_outpoint || combined_pubkey)), scan_private_key
      ) as ecdh_shared_secret
    FROM scan_calculation
  ),
  
  -- Calculate the BIP 352 t_0
  t_0_calculation AS (
    SELECT 
      ecdh_shared_secret,
        
        -- Step 5: For k=0, compute t_0 = tagged_sha256("BIP0352/SharedSecret", input_hash || int_to_big_endian(0))
        secp256k1_tagged_sha256('BIP0352/SharedSecret',
          ecdh_shared_secret || int_to_big_endian(0)
        ) as t_0
        
      FROM secret_calculation
    )
SELECT secp256k1_ec_pubkey_combine([spend_pubkey, secp256k1_ec_pubkey_create(t_0)]) = from_hex('033e9fce73d4e77a4809908e3c3a2e54ee147b9312dc5044a193d1fc85de46e3c1')
FROM t_0_calculation, scan_calculation;
----
true

# BIP 352 Silent Payments tweak index test (k=0) using first test vector
# This calculates the tweak
query I
WITH 
  -- Input public keys from the test vector transaction (extracted from inputs)
  input_pubkeys AS (
    SELECT [
      secp256k1_ec_pubkey_create(from_hex('eadc78165ff1f8ea94ad7cfdc54990738a4c53f6e0507b42154201b8e5dff3b1')),  -- First input pubkey
      secp256k1_ec_pubkey_create(from_hex('93f5ed907ad5b2bdbbdcb5d9116ebc0a4e1f92f910d5260237fa45a9408aad16'))   -- Second input pubkey  
    ] as pubkeys
  ),
  
  -- Create outpoints from the test vector inputs
  outpoints AS (
    SELECT [
      create_outpoint(from_hex('f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16'), 0),
      create_outpoint(from_hex('a1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d'), 0)
    ] as ops
  ),
  
  combined_pubkey AS (
  	SELECT
  	  secp256k1_ec_pubkey_combine(pubkeys) as combined_pubkey
  	FROM input_pubkeys
  )
  
SELECT secp256k1_ec_pubkey_tweak_mul(combined_pubkey, 
                 secp256k1_tagged_sha256('BIP0352/Inputs', min_outpoint(ops) || combined_pubkey)) = from_hex('024ac253c216532e961988e2a8ce266a447c894c781e52ef6cee902361db960004')
  FROM combined_pubkey, outpoints;
----
true

# Test secp256k1_xonly_key_match function with direct match
query I
WITH test_data AS (
    SELECT 
        from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as x_only_key,
        from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as compressed_key
)
SELECT secp256k1_xonly_key_match(
    [hash_prefix_to_int(x_only_key, 0)],  -- BIGINT[] list containing first 8 bytes of G point's x value
    compressed_key,                       -- target compressed key (G point as compressed BLOB)
    []                                    -- empty compressed keys list
) FROM test_data;
----
true

# Test secp256k1_xonly_key_match function with no match
query I
WITH test_data AS (
    SELECT 
        from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as key1,
        secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as key2
)
SELECT secp256k1_xonly_key_match(
    [hash_prefix_to_int(key1, 0)],  -- BIGINT[] list containing first 8 bytes of G point's x value
    key2,                           -- different target compressed key
    []                              -- empty compressed keys list
) FROM test_data;
----
false

# Test secp256k1_xonly_key_match function with empty lists
query I
SELECT secp256k1_xonly_key_match(
    CAST([] AS BIGINT[]),                                                               -- empty BIGINT array
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),   -- target compressed key
    []                                                                                  -- empty compressed keys list
);
----
false

# Test secp256k1_xonly_key_match function with NULL inputs
query I
SELECT secp256k1_xonly_key_match(NULL, NULL, NULL);
----
NULL

# Test secp256k1_xonly_key_match function with invalid compressed key length
query I
SELECT secp256k1_xonly_key_match(
    [8646911284551352320],  -- Some BIGINT value
    from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'),  -- 31 bytes instead of 33
    []
);
----
NULL

# Test secp256k1_xonly_key_match function with key combination using BIGINT[] prefix matching
# This tests the core functionality with the new BIGINT[] first argument
query I
WITH test_keys AS (
    SELECT 
        secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) as g_point,      -- G
        secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as double_g,     -- 2G
        secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000003')) as triple_g      -- 3G
),
x_coords AS (
    SELECT 
        g_point, double_g, triple_g,
        from_hex(substring(to_hex(g_point), 3, 64)) as g_x,
        from_hex(substring(to_hex(triple_g), 3, 64)) as triple_g_x
    FROM test_keys
)
SELECT secp256k1_xonly_key_match(
    [hash_prefix_to_int(triple_g_x, 0)],  -- BIGINT[] with first 8 bytes of 3G x-coordinate
    g_point,                              -- Target: G point as compressed key
    [double_g]                            -- Compressed keys: 2G (G + 2G = 3G should match)
) FROM x_coords;
----
true

# Test secp256k1_xonly_key_match function with multiple BIGINT prefixes
query I
WITH test_data AS (
    SELECT 
        from_hex('1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef') as key1,
        from_hex('fedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321') as key2,
        from_hex('abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890') as key3,
        secp256k1_ec_pubkey_create(from_hex('1111111111111111111111111111111111111111111111111111111111111111')) as input_key
),
target_key AS (
    SELECT 
        input_key,
        from_hex(substring(to_hex(input_key), 3, 64)) as input_key_x
    FROM test_data
)
SELECT secp256k1_xonly_key_match(
    [hash_prefix_to_int(input_key_x, 0)],  -- BIGINT prefix of input key's x-coordinate
    input_key,                             -- Target as compressed key (should match directly)
    []                                     -- Empty compressed keys list
) FROM target_key;
----
true

# Test secp256k1_xonly_key_match function with invalid compressed key length
# Should continue processing and ignore invalid keys
query I
WITH test_data AS (
    SELECT 
        from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as x_only_key,
        from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as compressed_key
)
SELECT secp256k1_xonly_key_match(
    [hash_prefix_to_int(x_only_key, 0)],                                                               -- BIGINT[] with G point prefix
    compressed_key,                                                                                     -- Target: G compressed key
    [from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), compressed_key]     -- Invalid 32-byte + valid G compressed
) FROM test_data;
----
true

# Test secp256k1_xonly_key_match function with all invalid compressed keys
# Should return false since no valid combinations can be made and no direct match
query I
SELECT secp256k1_xonly_key_match(
    [1],  -- Different BIGINT prefix, no direct match
    from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),  -- Valid compressed key but won't match prefix
    [from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817'), from_hex('1234')]  -- All invalid compressed keys
);
----
false

# Test secp256k1_xonly_key_match function with NULL elements in lists
# Should skip NULL elements and process valid ones
query I
WITH test_data AS (
    SELECT 
        from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as x_only_key,
        from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as compressed_key
)
SELECT secp256k1_xonly_key_match(
    [NULL, hash_prefix_to_int(x_only_key, 0), NULL],                                                    -- BIGINT[] with NULLs and G prefix
    compressed_key,                                                                                      -- Target: G compressed key
    [NULL, compressed_key, NULL]                                                                        -- Compressed keys with NULLs and G compressed
) FROM test_data;
----
true

# Test secp256k1_xonly_key_match function comprehensive test with BIGINT[] format
# This test demonstrates the complete functionality in a single query with the new format
query I
WITH test_data AS (
    SELECT 
        from_hex('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as x_key1,
        from_hex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798') as comp_key1,
        secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as comp_key2
),
comprehensive_test AS (
    SELECT
        -- Direct match test
        secp256k1_xonly_key_match(
            [hash_prefix_to_int(x_key1, 0)], 
            comp_key1, 
            []
        ) as direct_match_test,
        
        -- No match test
        secp256k1_xonly_key_match(
            [hash_prefix_to_int(x_key1, 0)], 
            comp_key2, 
            []
        ) as no_match_test,
        
        -- Empty lists test
        secp256k1_xonly_key_match(
            CAST([] AS BIGINT[]), 
            comp_key1, 
            []
        ) as empty_lists_test,
        
        -- NULL test
        secp256k1_xonly_key_match(NULL, NULL, NULL) as null_test
    FROM test_data
)
SELECT 
    direct_match_test = true AND 
    no_match_test = false AND 
    empty_lists_test = false AND 
    null_test IS NULL
FROM comprehensive_test;
----
true

# Test scan_silent_payments function with no label tweaks (empty case)
query I
WITH 
  scan_priv AS (SELECT from_hex('0000000000000000000000000000000000000000000000000000000000000001') as key),
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as key),
  tweak_key AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000003')) as key),
  outputs AS (SELECT [8646911284551352320] as list), -- Dummy output that won't match
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    CAST([] AS BLOB[])  -- Empty label tweaks
);
----
false

# Test scan_silent_payments function with matching output (functional test)
query I
WITH 
  scan_priv AS (SELECT from_hex('0000000000000000000000000000000000000000000000000000000000000001') as key),
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as key),
  tweak_key AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000003')) as key),
  
  -- Calculate what the output should be for this specific input
  calculated_output AS (
    SELECT secp256k1_ec_pubkey_combine([
      (SELECT key FROM spend_pub),
      secp256k1_ec_pubkey_create(secp256k1_tagged_sha256('BIP0352/SharedSecret', 
        secp256k1_ec_pubkey_tweak_mul((SELECT key FROM tweak_key), (SELECT key FROM scan_priv)) || int_to_big_endian(0)))
    ]) as output_key
  ),
  
  -- Extract first 8 bytes as BIGINT
  output_prefix AS (
    SELECT hash_prefix_to_int(from_hex(substring(to_hex(output_key), 3, 64)), 0) as prefix
    FROM calculated_output
  ),
  
  outputs AS (SELECT [(SELECT prefix FROM output_prefix)] as list),
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    CAST([] AS BLOB[])  -- Empty label tweaks
);
----
true

# Test scan_silent_payments function with no label tweaks (BIP testcase)
query I
WITH 
  scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1f2c') as key),
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3')) as key),
  tweak_key AS (SELECT from_hex('024ac253c216532e961988e2a8ce266a447c894c781e52ef6cee902361db960004') as key),
  outputs AS (SELECT [4512552348537027144] as list), -- First 8 bytes of expected output x-coordinate
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    CAST([] AS BLOB[])  -- Empty label tweaks
);
----
true

# Test scan_silent_payments function with label tweaks
query I
WITH 
  scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1f2c') as key),
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3')) as key),
  tweak_key AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000002')) as key),
  
  -- Test with a label tweak key
  label_tweak AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) as key),
  
  outputs AS (SELECT [1234567890] as list), -- Dummy output that won't match
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array),
  tweaks AS (SELECT [(SELECT key FROM label_tweak)] as tweaks_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    (SELECT tweaks_array FROM tweaks)
);
----
false

# Test scan_silent_payments function with change label tweak (BIP testcase)
query I
WITH 
  scan_priv AS (SELECT from_hex('11b7a82e06ca2648d5fded2366478078ec4fc9dc1d8ff487518226f229d768fd') as key),
  spend_pub AS (SELECT from_hex('03ecd43b9fdad484ff57278b21878b844276ce390622d03dd0cfb4288b7e02a6f5') as key),
  tweak_key AS (SELECT from_hex('0314bec14463d6c0181083d607fecfba67bb83f95915f6f247975ec566d5642ee8') as key),
  label_tweak AS (SELECT from_hex('03ecd43b9fdad484ff57278b21878b844276ce390622d03dd0cfb4288b7e02a6f5') as key),
  outputs AS (SELECT [-4740445252767345406] as list), -- First 8 bytes of expected output x-coordinate
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array),
  tweaks AS (SELECT [(SELECT key FROM label_tweak)] as tweaks_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    (SELECT tweaks_array FROM tweaks)
);
----
true

# Test scan_silent_payments function with NULL inputs
query I
SELECT scan_silent_payments(NULL, NULL, NULL);
----
NULL

# Test scan_silent_payments function with invalid keys array length
query I
WITH 
  scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1f2c') as key),
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3')) as key),
  outputs AS (SELECT [1234567890] as list),
  keys AS (SELECT [(SELECT key FROM scan_priv), (SELECT key FROM spend_pub)] as keys_array)  -- Only two keys instead of three
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    CAST([] AS BLOB[])
);
----
NULL

# Test scan_silent_payments function with wrong key sizes
query I
WITH 
  wrong_scan_priv AS (SELECT from_hex('0f694e068028a717f8af6b9411f9a133dd3565258714cc226594b34db90c1') as key), -- 31 bytes instead of 32
  spend_pub AS (SELECT secp256k1_ec_pubkey_create(from_hex('9d6ad855ce3417ef84e836892e5a56392bfba05fa5d97ccea30e266f540e08b3')) as key),
  tweak_key AS (SELECT secp256k1_ec_pubkey_create(from_hex('0000000000000000000000000000000000000000000000000000000000000001')) as key),
  outputs AS (SELECT [1234567890] as list),
  keys AS (SELECT [(SELECT key FROM wrong_scan_priv), (SELECT key FROM spend_pub), (SELECT key FROM tweak_key)] as keys_array)
SELECT scan_silent_payments(
    (SELECT list FROM outputs),
    (SELECT keys_array FROM keys),
    CAST([] AS BLOB[])
);
----
NULL
